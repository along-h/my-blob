import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as a,a as l,e as s,f as r}from"./app-CaxZhZIt.js";const n={},o=l("p",null,"浏览器相关知识点如V8引擎、TCP连接过程、路由模式、本地存储方式等",-1),d=r(`<h1 id="浏览器相关知识点" tabindex="-1"><a class="header-anchor" href="#浏览器相关知识点" aria-hidden="true">#</a> 浏览器相关知识点</h1><h2 id="一、输入url的过程" tabindex="-1"><a class="header-anchor" href="#一、输入url的过程" aria-hidden="true">#</a> 一、输入URL的过程</h2><ol><li>对url进行解析，若非url结构则交给浏览器搜索引擎去搜索，是url结构的话交给网络进程</li><li>网络进程会先查看是否存在本地缓存，有的话返回缓存资源，没有的话进行DNS解析---&gt;解析后得到IP地址，假如是HTTPS协议还要建立TLS连接。</li><li>利用IP地址和服务器建立TCP连接，进行三次握手。连接建立之后，向服务器发送请求</li><li>服务器收到请求信息后，会根据请求信息返回指定的数据给浏览器</li><li>服务器接收数据后进行页面的渲染（解析HTML生成DOM树,解析CSS生成规则树，js引擎解析js,将DOM树和CSSOM树合成Renden渲染树树，然后计算布局，绘制页面）</li><li>渲染完毕后，四次挥手，关闭tcp连接</li></ol><h2 id="二、浏览器渲染过程" tabindex="-1"><a class="header-anchor" href="#二、浏览器渲染过程" aria-hidden="true">#</a> 二、浏览器渲染过程</h2><ol><li>解析HTML，生成DOM树；</li><li>解析CSS，生成CSSOM树；(不会中断后续的执行，因为浏览器会启动一个网络线程和预解析线程，率先下载和解析css)</li><li>js通过DOM API和CSSOM API操作DOM树和CSSOM树，将DOM树和CSSOM树合成渲染树（Render Tree）(会中断操作，等待js执行完再继续)</li><li>布局：根据生成的渲染树，进行回流，以计算每个节点的几何信息（位置、大小等等）(渲染主线程使用一套复杂的策略会对整个布局树进行分层处理，后续改变某个分层时只用对当面分层进行操作即可，提高效率)</li><li>绘制：根据渲染树和回流得到的几何信息，得到每个节点的绝对像素；</li><li>展示：将像素发送给图形处理器（GPU），展示在页面上</li></ol><h2 id="三、tcp为什么三次握手" tabindex="-1"><a class="header-anchor" href="#三、tcp为什么三次握手" aria-hidden="true">#</a> 三、TCP为什么三次握手</h2><ol><li>第一次握手：客户端向服务器端发送一段TCP报文，向服务端申请建立连接。</li><li>第二次握手：服务器端收到来自客户端的TCP报文后，返回一段TCP报文，告诉客户端，服务器端能正常接收客户端的消息，同意建立连接。</li><li>第三次握手：客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，最后返回一段TCP报文，告诉服务器，我知道你收到我发的数据了。</li></ol><p>只有三次握手后，客户端和服务器端才能知道双方的通信是正常的。</p><h2 id="四、tcp为什么要四次挥手" tabindex="-1"><a class="header-anchor" href="#四、tcp为什么要四次挥手" aria-hidden="true">#</a> 四、TCP为什么要四次挥手</h2><ol><li>第一次挥手：客户端想要释放连接，向服务器端发送一段TCP报文，申请释放连接。</li><li>第二次挥手：服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，返回一段TCP报文，表示“接收到客户端发送的释放连接的请求”。并进入半关闭状态。</li><li>第三次挥手：服务器端发出确认报文后，经过半关闭状态，做好释放连接的准备后，再向客户端发出一段TCP报文，告诉客户端，已经做好释放的准备。</li><li>第四次挥手：客户端收到服务器端TCP报文后，确认了服务器已做好释放的准备，向服务器端发送最后一段报文，告诉服务器端，已收到，你可以释放连接了</li></ol><p>只有四次挥手后，客户端才能知道服务器端已经做好了释放的准备，服务器端也能知道是否能释放连接，客户端是否做好准备</p><h2 id="五、浏览器的v8引擎-javascript和webassembly引擎" tabindex="-1"><a class="header-anchor" href="#五、浏览器的v8引擎-javascript和webassembly引擎" aria-hidden="true">#</a> 五、浏览器的V8引擎（JavaScript和WebAssembly引擎）</h2><h3 id="_5-1-v8引擎架构" tabindex="-1"><a class="header-anchor" href="#_5-1-v8引擎架构" aria-hidden="true">#</a> 5.1 V8引擎架构</h3><p><code>&lt;img src=&quot;/assets/images/browser1.png&quot; /&gt;</code></p><h3 id="_5-2-原理" tabindex="-1"><a class="header-anchor" href="#_5-2-原理" aria-hidden="true">#</a> 5.2 原理</h3><ol><li>V8对JS源代码通过parse进行词法分析、语法分析****生成AST抽象语法树</li></ol><ul><li>词法分析：生成tokens数组，tokens数组由多个对象组成，对象中包含了type与value等（如：{ type: &#39;keywords&#39;, value: &#39;const&#39;}）</li><li>语法分析：对其中的每个对象进行分析，根据其type分析成具体的语法，生成AST抽象语法树</li></ul><ol start="2"><li>拿到抽象语法树后，由ignition库（V8中的库）将****抽象语法树转成字节码（字节码可跨平台）</li></ol><ul><li>之所以不直接转为机器指令是因为JS运行环境是无法确定的（比如有可能运行在Mac上的Chrome，也可能运行在Windows上的Chrome），不同环境的CPU不同，对应的机器码也不同</li></ul><ol start="3"><li>V8再将字节码转成对应平台的机器指令</li><li>Ignition库会收集函数执行频率等信息，如果执行频率过多，那么就会****由TurboFan库直接变为机器码，就不用先转为字节码，再变为机器指令了（优化）</li><li>一旦发现下次执行机器指令时操作不同了，那么会进行反向优化，将优化的机器码转成字节码</li></ol><h3 id="_5-3-执行细节-js代码被解析过程" tabindex="-1"><a class="header-anchor" href="#_5-3-执行细节-js代码被解析过程" aria-hidden="true">#</a> 5.3 执行细节，JS代码被解析过程</h3><p>JavaScript源码被解析的过程：</p><ol><li>Bink将源码交给V8引擎，Stream获取到源码并且进行编码转换</li><li>Scanner会进行词法分析，词法分析会将代码转换成tokens数组</li><li>然后tokens会被转化为AST树，其间会经过****Parser（解析） 与PreParser（预解析）</li></ol><ul><li>Parser会直接将tokens转为AST</li><li>PreParser预解析，为什么要进行预解析呢？ <ul><li>是因为并不是所有的JS代码在一开始就是会被执行的（函数在被调用时才会执行），对所有的JS代码解析会影响网页的运行效率</li><li>于是V8引擎实现了延迟解决方案：将不必要的函数进行预解析，只解析暂时需要的内容</li><li>而对于函数的全量解析是在函数被调用时进行的</li></ul></li></ul><ol start="4"><li>生成AST树后，会被Ignition转成字节码，之后就是执行代码</li></ol><h3 id="_5-4-预解析" tabindex="-1"><a class="header-anchor" href="#_5-4-预解析" aria-hidden="true">#</a> 5.4 预解析</h3><ol><li>变量声明被提升：所有使用 <code>var</code>关键字声明的变量会被提升到当前作用域的顶部，并赋予默认值 <code>undefined</code>。</li><li>函数声明被提升：所有使用函数声明方式（而非函数表达式）定义的函数也会被提升到当前作用域的顶部，并可以在函数声明之前调用。</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>console.log(x); // undefined
var x = 5;
console.log(x); // 5

foo();

function foo() {
  console.log(&quot;Hello, foo!&quot;);
}

/*
输出结果：
undefined
5
Hello, foo!
*/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="六、哈希路由和history路由" tabindex="-1"><a class="header-anchor" href="#六、哈希路由和history路由" aria-hidden="true">#</a> 六、哈希路由和history路由</h2><h3 id="_6-1-后端路由" tabindex="-1"><a class="header-anchor" href="#_6-1-后端路由" aria-hidden="true">#</a> 6.1 后端路由</h3><p>后端路由：在前后端不分离的时代，路由都是通过服务端指定的，服务端根据客户端发来的HTTP请求，将返回的数据于模板引擎响应结果结合后进行渲染，将渲染完毕的页面发送给客户端。 优点：SEO友好，爬虫爬取到的页面就是最终的渲染结果。 缺点：每次发起请求都要刷新页面，用户体验不好，服务器压力大。</p><h3 id="_6-2-spa单页面应用" tabindex="-1"><a class="header-anchor" href="#_6-2-spa单页面应用" aria-hidden="true">#</a> 6.2 SPA单页面应用</h3><p>一个web项目只有一个html文件，一旦页面加载完成，SPA不会因为用户的操作进行重新加载或跳转，而是用JS动态变换html的内容（使页面无需重新加载，用户体验更加流程），页面本身的url并没有变化，这会有两个问题： 1. SPA无法就记住用户的操作：刷新 &amp; 前进 &amp; 后退 1. 实际只有一个url，对SEO不友好，爬虫获取到的html只是模板而不是最终的页面。</p><p>前端路由的由来</p><p>可以理解成是基于SPA页面局部更新特点的，但是要解决SPA的两个问题，实现：</p><ul><li>改变url不让浏览器向服务器发送请求</li><li>监听url的变化，执行对应的操作</li></ul><h3 id="_6-3-hash路由" tabindex="-1"><a class="header-anchor" href="#_6-3-hash路由" aria-hidden="true">#</a> 6.3 hash路由</h3><p>hash路由就是路径前带#，通过监听hashchange事件，得到hash值，根据hash值匹配相应的组件进行展示。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>   // 监听URL的改变
    window.addEventListener(&quot;hashchange&quot;, () =&gt; {
      switch (location.hash) {
        case &quot;#/home&quot;:
          routerViewEl.innerHTML = &quot;首页&quot;;
          break;
        case &quot;#/about&quot;:
          routerViewEl.innerHTML = &quot;关于&quot;;
          break;
        default:
          routerViewEl.innerHTML = &quot;&quot;;
      }
    })
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>特点：</p><ul><li>hash指的就是url的#及后面的字符，如上面的“#hashhash”</li><li>hash值变化会触发hashchange事件</li><li>hash值变化会在浏览器的历史中留下记录，使用的浏览器的后退按钮可以回到上一个hash值</li><li>hash永远不会提交到服务器，即使刷新页面也不会</li></ul><p>优点：</p><ul><li>兼容性好，支持低版本和IE浏览器</li><li>实现前端路由无需服务端支持</li></ul><p>缺点：</p><ul><li>url带有#符号，略丑</li></ul><h3 id="_6-4-history路由" tabindex="-1"><a class="header-anchor" href="#_6-4-history路由" aria-hidden="true">#</a> 6.4 history路由</h3><p>history模式：利用h5 Api实现路由切换 包括两个方法：history.pushState和history.replaceState 一个事件：window.onpopstate 通过这两个方法和事件实现组件的切换，并且需要nginx上做配置</p><p>history还有其他方法，go，forward,back</p><p>window.onpopstate能监听到浏览器的前进后退，go，forward,back，但是监听不到history.pushState和history.replaceState方法，此时需要手动调用render函数</p><p>浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404 了。所以需要后端进行代理配置</p><h2 id="七、cookie、localstorage、session、sessionstorage区别" tabindex="-1"><a class="header-anchor" href="#七、cookie、localstorage、session、sessionstorage区别" aria-hidden="true">#</a> 七、cookie、localStorage、session、sessionStorage区别</h2><h3 id="_7-1-cookie" tabindex="-1"><a class="header-anchor" href="#_7-1-cookie" aria-hidden="true">#</a> 7.1 cookie</h3><p>cookie大小较小一般只有4kb，保存在客户端，客户端向服务器端发送一个请求的时，服务端向客户端发送一个Cookie 然后浏览器将Cookie保存，Cookie有两种保存方式，一种是浏览器会将CCookie保存在内存中，还有一种是保存在客户端的硬盘中，之后每次HTTP请求浏览器都会将Cookie发送给服务器端。可以设置Expire值，指定其生存时间。</p><p><strong>缺点：</strong></p><ol><li><strong>数量受到限制，一个浏览器能创建的cookie最多300个</strong></li><li><strong>不安全，cookie存在客户端，可以伪造，服务端不知道是不是真实用户发送的</strong></li></ol><h3 id="_7-2-session" tabindex="-1"><a class="header-anchor" href="#_7-2-session" aria-hidden="true">#</a> 7.2 session</h3><p>session大小无限制，保存在服务器端，能保证其安全性，一般用于会话控制，保存用户的属性与配置信息，但是session过多的话服务器压力会比较大</p><h3 id="_7-3-sessionstorage" tabindex="-1"><a class="header-anchor" href="#_7-3-sessionstorage" aria-hidden="true">#</a> 7.3 sessionStorage</h3><p>sessionStorage一般5MB或更大，保存在客户端，与localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在sessionStorage 里面的数据在页面会话结束时会被清除。关闭浏览器/标签页会自动清除</p><h3 id="_7-4-localstorage" tabindex="-1"><a class="header-anchor" href="#_7-4-localstorage" aria-hidden="true">#</a> 7.4 localStorage</h3><p><strong>localStorage一般5MB或更大，保存在客户端，存储在 localStorage 的数据****可以长期保留</strong>，关闭浏览器/标签页时，数据仍然存在。需要手动清除</p>`,61);function t(h,c){return a(),i("div",null,[o,s(" more "),d])}const p=e(n,[["render",t],["__file","browser.html.vue"]]);export{p as default};
