---
icon: tip
cover: /assets/images/completeProcess.png
date: 2023-03-07
category:
  - 浏览器
---
浏览器相关知识点如V8引擎、TCP连接过程、路由模式、本地存储方式等

<!-- more -->

# 浏览器相关知识点

## 一、输入URL的过程

1. 对url进行解析，若非url结构则交给浏览器搜索引擎去搜索，是url结构的话交给网络进程
2. 网络进程会先查看是否存在本地缓存，有的话返回缓存资源，没有的话进行DNS解析--->解析后得到IP地址，假如是HTTPS协议还要建立TLS连接。
3. 利用IP地址和服务器建立TCP连接，进行三次握手。连接建立之后，向服务器发送请求
4. 服务器收到请求信息后，会根据请求信息返回指定的数据给浏览器
5. 服务器接收数据后进行页面的渲染（解析HTML生成DOM树,解析CSS生成规则树，js引擎解析js,将DOM树和CSSOM树合成Renden渲染树树，然后计算布局，绘制页面）
6. 渲染完毕后，四次挥手，关闭tcp连接

## 二、浏览器渲染过程

1. 解析HTML，生成DOM树；
2. 解析CSS，生成CSSOM树；(不会中断后续的执行，因为浏览器会启动一个网络线程和预解析线程，率先下载和解析css)
3. js通过DOM API和CSSOM API操作DOM树和CSSOM树，将DOM树和CSSOM树合成渲染树（Render Tree）(会中断操作，等待js执行完再继续)
4. 布局：根据生成的渲染树，进行回流，以计算每个节点的几何信息（位置、大小等等）(渲染主线程使用一套复杂的策略会对整个布局树进行分层处理，后续改变某个分层时只用对当面分层进行操作即可，提高效率)
5. 绘制：根据渲染树和回流得到的几何信息，得到每个节点的绝对像素；
6. 展示：将像素发送给图形处理器（GPU），展示在页面上

## 三、TCP为什么三次握手

1. 第一次握手：客户端向服务器端发送一段TCP报文，向服务端申请建立连接。
2. 第二次握手：服务器端收到来自客户端的TCP报文后，返回一段TCP报文，告诉客户端，服务器端能正常接收客户端的消息，同意建立连接。
3. 第三次握手：客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，最后返回一段TCP报文，告诉服务器，我知道你收到我发的数据了。

只有三次握手后，客户端和服务器端才能知道双方的通信是正常的。

## 四、TCP为什么要四次挥手

1. 第一次挥手：客户端想要释放连接，向服务器端发送一段TCP报文，申请释放连接。
2. 第二次挥手：服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，返回一段TCP报文，表示“接收到客户端发送的释放连接的请求”。并进入半关闭状态。
3. 第三次挥手：服务器端发出确认报文后，经过半关闭状态，做好释放连接的准备后，再向客户端发出一段TCP报文，告诉客户端，已经做好释放的准备。
4. 第四次挥手：客户端收到服务器端TCP报文后，确认了服务器已做好释放的准备，向服务器端发送最后一段报文，告诉服务器端，已收到，你可以释放连接了

只有四次挥手后，客户端才能知道服务器端已经做好了释放的准备，服务器端也能知道是否能释放连接，客户端是否做好准备

## 五、浏览器的V8引擎（JavaScript和WebAssembly引擎）

### 5.1 V8引擎架构

`<img src="/assets/images/browser1.png" />`

### 5.2 原理

1. V8对JS源代码通过parse进行词法分析、语法分析****生成AST抽象语法树

* 词法分析：生成tokens数组，tokens数组由多个对象组成，对象中包含了type与value等（如：{ type: 'keywords', value: 'const'}）
* 语法分析：对其中的每个对象进行分析，根据其type分析成具体的语法，生成AST抽象语法树

2. 拿到抽象语法树后，由ignition库（V8中的库）将****抽象语法树转成字节码（字节码可跨平台）

* 之所以不直接转为机器指令是因为JS运行环境是无法确定的（比如有可能运行在Mac上的Chrome，也可能运行在Windows上的Chrome），不同环境的CPU不同，对应的机器码也不同

3. V8再将字节码转成对应平台的机器指令
4. Ignition库会收集函数执行频率等信息，如果执行频率过多，那么就会****由TurboFan库直接变为机器码，就不用先转为字节码，再变为机器指令了（优化）
5. 一旦发现下次执行机器指令时操作不同了，那么会进行反向优化，将优化的机器码转成字节码

### 5.3 执行细节，JS代码被解析过程

JavaScript源码被解析的过程：

1. Bink将源码交给V8引擎，Stream获取到源码并且进行编码转换
2. Scanner会进行词法分析，词法分析会将代码转换成tokens数组
3. 然后tokens会被转化为AST树，其间会经过****Parser（解析） 与PreParser（预解析）

* Parser会直接将tokens转为AST
* PreParser预解析，为什么要进行预解析呢？
  * 是因为并不是所有的JS代码在一开始就是会被执行的（函数在被调用时才会执行），对所有的JS代码解析会影响网页的运行效率
  * 于是V8引擎实现了延迟解决方案：将不必要的函数进行预解析，只解析暂时需要的内容
  * 而对于函数的全量解析是在函数被调用时进行的

4. 生成AST树后，会被Ignition转成字节码，之后就是执行代码

### 5.4 预解析

1. 变量声明被提升：所有使用 `var`关键字声明的变量会被提升到当前作用域的顶部，并赋予默认值 `undefined`。
2. 函数声明被提升：所有使用函数声明方式（而非函数表达式）定义的函数也会被提升到当前作用域的顶部，并可以在函数声明之前调用。

```
console.log(x); // undefined
var x = 5;
console.log(x); // 5

foo();

function foo() {
  console.log("Hello, foo!");
}

/*
输出结果：
undefined
5
Hello, foo!
*/
```

## 六、哈希路由和history路由

### 6.1 后端路由

后端路由：在前后端不分离的时代，路由都是通过服务端指定的，服务端根据客户端发来的HTTP请求，将返回的数据于模板引擎响应结果结合后进行渲染，将渲染完毕的页面发送给客户端。
	优点：SEO友好，爬虫爬取到的页面就是最终的渲染结果。
	缺点：每次发起请求都要刷新页面，用户体验不好，服务器压力大。

### 6.2 SPA单页面应用

一个web项目只有一个html文件，一旦页面加载完成，SPA不会因为用户的操作进行重新加载或跳转，而是用JS动态变换html的内容（使页面无需重新加载，用户体验更加流程），页面本身的url并没有变化，这会有两个问题：
		1.	SPA无法就记住用户的操作：刷新 & 前进 & 后退
		1.	实际只有一个url，对SEO不友好，爬虫获取到的html只是模板而不是最终的页面。

前端路由的由来

可以理解成是基于SPA页面局部更新特点的，但是要解决SPA的两个问题，实现：

* 改变url不让浏览器向服务器发送请求
* 监听url的变化，执行对应的操作

### 6.3 hash路由

hash路由就是路径前带#，通过监听hashchange事件，得到hash值，根据hash值匹配相应的组件进行展示。

```
   // 监听URL的改变
    window.addEventListener("hashchange", () => {
      switch (location.hash) {
        case "#/home":
          routerViewEl.innerHTML = "首页";
          break;
        case "#/about":
          routerViewEl.innerHTML = "关于";
          break;
        default:
          routerViewEl.innerHTML = "";
      }
    })
```

特点：

* hash指的就是url的#及后面的字符，如上面的“#hashhash”
* hash值变化会触发hashchange事件
* hash值变化会在浏览器的历史中留下记录，使用的浏览器的后退按钮可以回到上一个hash值
* hash永远不会提交到服务器，即使刷新页面也不会

优点：

* 兼容性好，支持低版本和IE浏览器
* 实现前端路由无需服务端支持

缺点：

* url带有#符号，略丑

### 6.4 history路由

history模式：利用h5 Api实现路由切换
包括两个方法：history.pushState和history.replaceState
一个事件：window.onpopstate
通过这两个方法和事件实现组件的切换，并且需要nginx上做配置

history还有其他方法，go，forward,back

window.onpopstate能监听到浏览器的前进后退，go，forward,back，但是监听不到history.pushState和history.replaceState方法，此时需要手动调用render函数

浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404 了。所以需要后端进行代理配置

## 七、cookie、localStorage、session、sessionStorage区别

### 7.1 cookie

cookie大小较小一般只有4kb，保存在客户端，客户端向服务器端发送一个请求的时，服务端向客户端发送一个Cookie 然后浏览器将Cookie保存，Cookie有两种保存方式，一种是浏览器会将CCookie保存在内存中，还有一种是保存在客户端的硬盘中，之后每次HTTP请求浏览器都会将Cookie发送给服务器端。可以设置Expire值，指定其生存时间。

**缺点：**

1. **数量受到限制，一个浏览器能创建的cookie最多300个**
2. **不安全，cookie存在客户端，可以伪造，服务端不知道是不是真实用户发送的**

### 7.2 session

session大小无限制，保存在服务器端，能保证其安全性，一般用于会话控制，保存用户的属性与配置信息，但是session过多的话服务器压力会比较大

### 7.3 sessionStorage

sessionStorage一般5MB或更大，保存在客户端，与localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在sessionStorage 里面的数据在页面会话结束时会被清除。关闭浏览器/标签页会自动清除

### 7.4 localStorage

**localStorage一般5MB或更大，保存在客户端，存储在 localStorage 的数据****可以长期保留**，关闭浏览器/标签页时，数据仍然存在。需要手动清除
